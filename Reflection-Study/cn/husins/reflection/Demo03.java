package cn.husins.reflection;

/*
    Java内存分析：
        堆：存放new的对象和数组，可以被所有线程共享，不会存放别的对象引用

        栈：存放基本变量类型（包含这个基本类型的具体数值），引用对象的变量（会存放这个引用在堆里面具体的地址）

        方法区：一个特殊的堆，可以被所有线程共享，包含了所有的class和static变量

    类的加载过程：
        当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过如下三个步骤对该类进行初始化：
            1. 类加载（Load）： 将类的Class文件读入内存，也就是把静态数据转化为方法区的运行时的数据结构，
               并为之创建一个java.lang.Class对象。此过程由类加载器完成。Class对象只能获取不能主动创建
            2. 类的链接（Link）： 将类的二进制数据合并到JRE中
                - 验证： 确保加载的类信息符合JVM规范，没有安全方面的问题
                - 准备： 正式为类变量static分配内存并设置类变量默认初始化的阶段，这些内存都将在方法区中进行分配，这也解答了static为啥能直接调用
                        ，在类的链接过程中已经开辟了内存空间
                - 解析： 虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程
            3. 类的初始化（Initialize）： JVM负责对类进行初始化
                - 执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并
                  产生的。类构造器是构造类信息的，不是构造该类对象的构造器
                - 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
                - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步
 */

public class Demo03 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(A.m);
        /*
        result:
            A类静态代码块初始化
            A类代码块初始化
            A类的无参构造初始化
            100
         */

    }
}

class A{

    public A() {
        System.out.println("A类的无参构造初始化");
    }

    {
        System.out.println("A类代码块初始化");
    }

    static {
        System.out.println("A类静态代码块初始化");
        m = 300;
    }
    static int m = 100;
}